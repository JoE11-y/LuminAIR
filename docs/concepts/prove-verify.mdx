---
title: Prove & Verify
description: Ensuring Computational Integrity with LuminAIR.
---

LuminAIR’s primary objective is to cryptographically prove that a computational graph has been executed correctly. 
This proof allows verifiers to validate the computation’s integrity using significantly fewer resources than re-executing the graph. 
The process is powered by the `StwoCompiler` and the Stwo prover, enabling efficient proof generation and verification.

# What is Stwo?
[Stwo](https://github.com/starkware-libs/stwo) is a next-generation implementation of the [Circle STARK](https://eprint.iacr.org/2024/278) protocol, written in Rust. 

Developed by Starkware, it is an ultra-efficient ZK prover designed for scalable succinct proofs. Stwo unlocks the potential of the highly efficient prime field M31, benefiting the entire ZK-proof ecosystem.

# How LuminAIR Leverages Stwo

The `StwoCompiler` plays a critical role in transforming and optimizing computational graphs. 
It assigns each operator in the graph to its corresponding AIR component, preparing the graph for proof generation using the Stwo prover.

# LuminAIR Prover
The LuminAIR prover integrates directly with the Stwo library to:
1. Implement AIR components for each operator in the computational graph.
2. Generate an execution trace, which records the state of each operation during execution.
3. Produce succinct proofs.

### SIMD Backend for Parallelization

The LuminAIR prover currently supports a SIMD backend, allowing parallelized proof generation on devices equipped with SIMD capabilities. 
For smaller traces or devices without SIMD support, a fallback to `CpuBackend` ensures compatibility.

### Future Plans: GPU Acceleration

In the roadmap, LuminAIR plans to support [Icicle-Stwo](https://github.com/ingonyama-zk/icicle-stwo), an implementation of Stwo by [Ingonyama](https://www.ingonyama.com/) that enables CUDA-based GPU acceleration.
This will significantly enhance proof generation speed for large-scale computation

# LuminAIR Verifier
The LuminAIR verifier, written in Rust, validates proofs generated by the prover. It ensures:
1. The LogUp sum is correct (Cf. [integrity section](/concepts/integrity)).
2. The proof satisfies all constraints defined by the AIR components.

### Future Plans

To expand its trustlessness, LuminAIR plans to implement additional verifier backends:

1. **WASM Verifier**:
	A WebAssembly implementation will allow proofs to be verified directly in web browsers, enabling trustless verification by a client.

2. **Onchain Verification**:
    - Implementing the verifier as a [Cairo](https://www.cairo-lang.org/) program verified onchain.
    - Using [AVSs](https://app.eigenlayer.xyz/avs) like [Aligned Layer](https://alignedlayer.com/) to leverage Ethereum’s crypto-economic security.
